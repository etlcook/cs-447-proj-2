#this is the HTTP server

import os
import sys
import base64
import string
import random
import socket
import threading
import datetime

def createAuthFileIfNeeded():
    path = os.getcwd()
    path = path + '/db'
    # create hidden username:password file if not exists
    if not os.path.exists(path + "/.user_pass"):
        k = open(path + '/.user_pass', 'w')
        k.close()
    # create hidden server log file if not exists
    if not os.path.exists(path + "/.server_log"):
        print('creating hidden server_log file')
        q = open(path + '/.server_log', 'w')
        q.close()

def readFromConf():
    #pull data from the server.conf file
    config = open('server.conf', 'r')
    configValues = config.read()
    configList = configValues.split('\n')
    otherServers = []
    i = 0
    for line in configList:
        if line == '[SELF]':
            DOMAIN = str(configList[i + 1]).split("=")[1]
            SELF_IP = str(configList[i + 2]).split("=")[1]
            SMTP_PORT = str(configList[i + 3]).split("=")[1]
            HTTP_PORT = str(configList[i + 4]).split("=")[1]

        #add all other server info to list, stored as [ip1, port1, ip2, port2, ...]
        elif line == '[REMOTE]':
            otherDomain = str(configList[i + 1]).split("=")[1]
            otherIP = str(configList[i + 2]).split("=")[1]
            otherPort = str(configList[i + 3]).split("=")[1]
            otherServers.append(otherDomain)
            otherServers.append(otherIP)
            otherServers.append(otherPort)

        i = i + 1

    print('HTTP port: ', HTTP_PORT, '\n')
    config.close()
    return DOMAIN, SELF_IP, SMTP_PORT, HTTP_PORT, otherServers

# create password for new user and add to user_pass file
def authNew(conn, username):
    source = string.ascii_letters + string.digits
    password = ''.join((random.choice(source) for i in range(6)))
    prefixPass = '447S21' + str(password)
    prefixPass = prefixPass.encode()
    saltedPassword = base64.b64encode(prefixPass)
    path = os.getcwd() + "/db/.user_pass"
    credFile = open(path, 'a+')
    credStr = credFile.read()
    credStr = credStr + username + ':' + str(saltedPassword) + '\n'
    credFile.write(credStr)
    credFile.close()
    msg = password
    msg = msg.encode()
    msg = base64.b64encode(msg)
    conn.sendall(b'330 ' + msg)
    logActs('AUTH', '330', 'autogenerated password')
    return

# same as SMTP suth
def auth(conn):
    username = base64.b64decode(conn.recv(1024))
    logActs('AUTH', 'na', 'username', 'in')
    username = username.decode()
    path = os.getcwd() + "/db/.user_pass"
    credFile = open(path, 'r')
    credString = str(credFile.read())
    exists = False
    credList = credString.split('\n')
    for item in credList:
        keyValPair = item.split(':')
        if keyValPair[0] == username:
            truePassword = keyValPair[1]
            exists = True
            break
    credFile.close()
    # if new user, make them a password and end connection
    if exists is False:
        authNew(conn, username)
        sys.exit()

    else:
        conn.sendall('334 cGFzc3dvcmQ6'.encode())
        logActs('AUTH', '334 cGFzc3dvcmQ6', 'password prompt')
        while True:
            password = conn.recv(1024)
            logActs('AUTH', 'na', 'password', 'in')

            password = base64.b64decode(password)
            password = password.decode()
            password = '447S21' + password
            password = password.encode()
            password = base64.b64encode(password)
            # make sure user_pass matches entered password
            if str(password) == truePassword:
                conn.sendall("235 AUTH successful".encode())
                logActs('AUTH', '235', 'successfull authorization')
                return True, username
            else:
                conn.sendall("535 invalid credentials. re-enter password".encode())
                logActs('AUTH', '535', 'invalid credentials')

#this will manipulate the request string to get needed data
def processGet(conn, req):

    reqLines = req.splitlines()
    line1 = reqLines[0].split()
    line3 = reqLines[2].split()
    if line1[0] != "GET":
        badReq(conn)

    userPath = os.getcwd()
    userPath = userPath + line1[1]
    try:
        emailCount = int(line3[1])
        emailsLeft = int(line3[1])
    except:
        badReq()
    
    #this makes sure the user has a database directory
    if os.path.exists(userPath):
        return True, userPath, emailCount, emailsLeft
    else:
        return False, '', 0, 0

def badReq(conn):
    conn.sendall("400 bad GET request, closing..".encode())
    logActs('GET', '400', 'bad GET request')
    sys.exit()

# logs everything to standard output and to server_log file
def logActs(command, code, description = '', msgDirection = 'out', remIP = ''):
    logPath = os.getcwd() + '/db/.server_log'
    logFile = open(logPath, 'a')
    if not remIP:
        remIP = addr[0]
    if msgDirection == 'out':
        logString = str(datetime.datetime.now())
        logString += ' from-' + SELF_IP + ' to-' + remIP + ' HTTP-' + command + ' ' + code + ' ' + description
        logFile.write(logString)
        print(logString)
        logFile.close()
    elif msgDirection == 'in':
        logString = str(datetime.datetime.now())
        logString += ' from-' + remIP + ' to-' + SELF_IP + ' HTTP-' + command + ' ' + code + ' ' + description
        logFile.write(logString)
        print(logString)
        logFile.close()

#first authorize, then let user know how many new emails there are to read.
def main(servSock, conn, addr, DOMAIN):
    authorized, username = auth(conn)
    if authorized:
        # give user number of emails
        userPath = os.getcwd() + '/db/' + username
        if not os.path.exists(userPath):
            resp = 'no emails to be read at this time, have a nice day..'
            conn.sendall(resp.encode())
            logActs('setup', 'na', 'user has no emails yet')
            sys.exit()
        filenames = os.listdir(userPath)
        filenames.remove('nextnum.txt')
        if len(filenames) <= 0:
            resp = 'no emails to be read at this time, have a nice day..'
            conn.sendall(resp.encode())
            logActs('setup', 'na', 'user has no new emails')
            sys.exit()
        else:
            conn.sendall(str(len(filenames)).encode())
            logActs('setup', 'na', 'let user know how many new emails there are')

        # receive get request
        req = conn.recv(1024).decode()
        logActs('GET', 'na', 'GET REQ submission', 'in')

        # this function decides if the data is usable
        pathExists, userPath, emailCount, emailsLeft = processGet(conn, req)
        if pathExists:
            # get list of filenames minus nextnum.txt
            filenames = os.listdir(userPath)
            filenames.remove('nextnum.txt')
            if len(filenames) < emailCount:
                badReq(conn)
            emailObjects = []
            while emailsLeft > 0:
                # iter starts at 0 and increments, file is each file in filenames
                # everything is appended to emailObj
                iter = emailCount - emailsLeft
                emailStr = 'Message: ' + str(iter + 1) + '\n'
                file = open(userPath + '/' + str(filenames[iter]), 'r')
                emailStr = emailStr + str(file.read())
                emailObjects.append(str(emailStr))
                file.close()
                #delete file so It won't be sent again
                os.remove(userPath + '/' + str(filenames[iter]))

                emailsLeft = emailsLeft - 1
        else:
            resp = 'no emails to be read at this time, have a nice day..'
            conn.sendall(resp.encode())
            logActs('setup', 'na', 'user has no emails to read')
            sys.exit()
    else:
        resp = '535 invalid credentials. exiting..'
        conn.sendall(resp.encode())
        logActs('AUTH', '535', 'invalid credentials')
        sys.exit()

    resp = 'HTTP/1.1 200 OK\nServer: ' + socket.gethostname() + '\nCount: ' + str(
        emailCount) + '\nContent-Type: text/plain\n'

    # add all email objects to the response string
    for email in emailObjects:
        resp = resp + email

    # send the HTTP response
    conn.sendall(resp.encode())
    logActs('GET', 'na', 'HTTP GET response')

if __name__ == "__main__":
    DOMAIN, SELF_IP, SMTP_PORT, HTTP_PORT, otherServers = readFromConf()
    createAuthFileIfNeeded()
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as servSock:
        servSock.bind(('', int(HTTP_PORT)))
        servSock.listen()
        print('server is running...')
        while True:
            conn, addr = servSock.accept()
            print('connected by: ', addr)
            try:
                x = threading.Thread(target=main,
                                     args=(servSock, conn, addr, DOMAIN))
                x.start()
            except threading.error as e:
                print(str(e))
                print('closing from threading exception..')
                sys.exit()

#go back to server options menu
os.system('python server-driver.py')
